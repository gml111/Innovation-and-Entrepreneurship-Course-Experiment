# SM2 算法实现、攻击与签名伪造
&emsp;&emsp;SM2 是我国自主设计的椭圆曲线公钥密码算法，在数字签名、密钥交换等场景广泛应用。本实验通过代码实现 SM2 核心功能，深入剖析其数学原理与工程实现逻辑，验证算法在密钥生成、签名及验证流程的正确性。

## 1.SM2 算法的实现
### 1.1 SM2 算法数学推导
#### 1.1.1 椭圆曲线基础
SM2 基于**素域椭圆曲线** \( y^2 \equiv x^3 + ax + b \pmod{p} \)，参数说明如下：  
-**素数参数**  
```plaintext
  p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF
```
-**曲线系数**
```plaintext
  a = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF  
  b = 0x28E9FA9E9D9F5E344D5AEF7F6B1B5314E5E78F29FA5FD03F86704BD0B8F1CF1
```
-**基点** \( G = (G_x, G_y) \)，阶 \( n \)：
```plaintext
  n = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123
```
#### 1.1.2 密钥对生成


1. **私钥**：随机选取 <code>d ∈ [1, n - 1]</code>，满足离散均匀分布。

2. **公钥**：通过椭圆曲线点乘计算 <code>P = d · G</code>（<code>G</code> 为基点），数学表达：  
   ```math
   P = \underbrace{G + G + \cdots + G}_{d \text{ 次}}

#### 1.1.3 数字签名（SM2 签名算法）

对消息 <code>m</code> 签名时：

**哈希预处理**：计算 <code>e = SM3(Z<sub>A</sub> ∥ m)</code>
（<code>Z<sub>A</sub></code> 为用户标识与公钥的哈希，用于身份绑定）

**随机数生成**：选取 <code>k ∈ [1, n - 1]</code>，计算 <code>(x<sub>1</sub>, y<sub>1</sub>) = k · G</code>

**签名参数**：

   ```math
r = (e + x₁) mod n
s = ( (1 + d)⁻¹ · (k - r · d) ) mod n 

 ```
最终签名为 <code>(r, s)</code>，需满足 <code>r ≠ 0</code> 且 <code>s ≠ 0</code>

### 1.2 SM2 算法代码实现
#### 1.2.1 核心数学操作封装

##### 椭圆曲线运算：
- **点加（elliptic_add）**：通过斜率公式实现 \( P_1 + P_2 \)，处理特殊情况（如相同点、无穷远点）。
- **倍点（elliptic_double）**：优化点加逻辑，实现 \( P + P \) 的高效计算。
- **点乘（elliptic_multiply）**：通过二进制展开（快速幂思想），将 \( k \cdot G \) 转换为多次倍点与点加操作，降低时间复杂度。

##### 模逆运算：
  ```math
通过扩展欧几里得算法（mod_inv）求解  a^{-1} \bmod p ，满足  a \cdot a^{-1} \equiv 1 \pmod{p} ，为点乘、签名参数计算提供基础支持。
  ```

#### 1.2.2 SM2 类设计

##### 初始化逻辑：
支持固定密钥（调试模式）或动态生成，通过 `DEBUG_FIXED_KEYS` 控制私钥/公钥生成行为。

##### 密钥生成：
`generate_key_pair` 随机选取私钥，通过点乘生成公钥，完成 \( Z_A \) 预计算（`get_za` 封装用户标识与曲线参数的哈希流程）。

##### 签名与验证：
- `sign` 按 SM2 签名流程，封装随机数生成、参数计算与边界检查（避免 \( r/s = 0 \) 等无效情况）。
- `verify` 还原验证流程，对比 \( r \) 的计算值与签名值，判断签名有效性。


#### 1.2.3 调试与扩展

##### 固定参数调试：
通过 `DEBUG_FIXED_KEYS`、`DEBUG_FIXED_K` 固定私钥、随机数 \( k \)，简化测试用例复现与问题定位。

##### 哈希与用户标识：
`get_za` 封装 SM3 哈希流程，支持自定义用户标识（`user_id`），实现身份与公钥的绑定验证。

### 1.3 SM2 算法运行结果
SM2算法运行结果如下：
![实际输出结果](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project5/results/SM2.png)


## 2.SM2 算法攻击方式
SM2 作为我国商用密码体系的重要公钥密码算法，在保障信息安全中发挥关键作用。然而，若实现或使用不当（如随机数泄露、重复使用等），会引发安全风险。本实验聚焦**k 值泄露攻击、相同 k 值重复使用攻击、多用户共享 k 值攻击**，剖析攻击原理与实现思路，揭示 SM2 算法安全边界。

## 2.1 攻击原理与实现思路
### 2.1.1 k 值泄露攻击
#### 原理
SM2 签名中，随机数 k 是核心参数。若 k 泄露，攻击者可通过签名公式反推私钥 d：  
签名满足
```math
s = (1 + d)^{-1} \cdot (k - r \cdot d) \pmod{n}，整理得：  d = \frac{k - s}{r + s} \pmod{n}  
  ```
已知k, r, s  时，可直接计算私钥d。  


#### 实现思路
1. **获取参数**：收集签名(r, s)、泄露的k、消息m及公钥P。  

2. **公式反推**：
```math
代入d = \frac{k - s}{r + s} \pmod{n}，
  ```
通过**模逆运算**计算
```math
(r + s)^{-1} \pmod{n}
  ```
 ，最终得到 d 。
### 2.1.2 相同 k 值重复使用攻击

#### 原理  
SM2 签名中，随机数 $\( k \)$ 是核心参数。若同一 $\( k \)$ 用于多消息签名，设两签名为 $\( (r_1, s_1) \)$ 、 $\( (r_2, s_2) \)$ ，对应消息哈希 $\( e_1, e_2 \)$ ，则签名满足：  

$$
\begin{cases} 
s_1 = (1 + d)^{-1} \cdot (k - r_1 \cdot d) \pmod{n} \\ 
s_2 = (1 + d)^{-1} \cdot (k - r_2 \cdot d) \pmod{n} 
\end{cases}
$$  

消去 \( (1 + d)^{-1} \) 后，可联立解出 \( k \)，再代入**单消息攻击公式** $\( d = \frac{k - s}{r + s} \pmod{n} \)$ 推导私钥 \( d \)。  


#### 实现思路  
1. **参数收集**：  
   获取同一 k 生成的多组签名 $\( (r_1, s_1)$ 、 $(r_2, s_2) \)$ ，及对应消息的哈希 $\( e_1, e_2 \)$、公钥 P 。  

2. **解算 k**：  
   联立两签名方程，消去
```math
(1 + d)^{-1} 
```
，推导 k 的计算公式（需通过**模逆运算**处理分母）。  

4. **推导私钥**：  
   将解出的 k 代入单消息攻击公式
 ```math
   d = \frac{k - s}{r + s} \pmod{n} ，
```
计算私钥 d 。（注：实际实现需处理模运算边界，如分母非零、结果取模等。）  

### 2.1.3 多用户共享 k 值攻击
#### 原理  
多用户共享 \( k \) 时，每个用户签名满足：
```math
s_i = (1 + d_i)^{-1} \cdot (k - r_i \cdot d_i) \mod n 
```
攻击者通过单个用户的 $\( (r_i, s_i, k) \)$ ，代入推导私钥 $\( d_i \)$ ：  
```math
d_i = \frac{k - s_i}{r_i + s_i} \mod n
```  


#### 实现思路  
1. **用户隔离**：针对每个用户，收集其签名 $\( (r_i, s_i) \)$ 、消息 $\( m_i \)$ 、公钥 $\( P_i \)$ 及 k 。  
2. **逐用户推导**：对每个用户，独立应用公式计算其私钥：
```math
d_i = \frac{k - s_i}{r_i + s_i} \mod n
```  


### 2.2 攻击场景与风险  

| 攻击类型          | 触发条件                     | 风险影响                     |  
| ----------------- | ---------------------------- | ---------------------------- |  
| \( k \) 值泄露攻击   | \( k \) 因代码漏洞 / 日志泄露  | 单用户私钥直接暴露           |  
| 相同 \( k \) 重复攻击 | 开发疏忽复用 \( k \)          | 多消息关联，批量推导私钥     |  
| 多用户共享 \( k \) 攻击 | 多用户密钥生成逻辑缺陷       | 多用户私钥批量泄露，危害扩大 |  


## 3. SM2 算法攻击结果
具体的攻击结果展示如下：
![实际输出结果](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project5/results/attack_k1.png)
![实际输出结果](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project5/results/attacke_k2_3.png)
-**具体分析**：
#### 攻击 1：k 值泄露攻击
- **判定结果**：成功
- **分析**：  
  推导私钥与真实私钥完全一致（`0x128b2fa8bd433c6c068c8d803dff79792a519a55171b1b650c23661d15897263`），符合 $d = (k - s)/(r + s) \mod n$ 的数学推导逻辑，证明代码正确复现了 k 值泄露攻击的公式，无计算误差。


#### 攻击 2：相同 k 值重复使用攻击
- **判定结果**：失败
- **分析**：  
  推导私钥（`0x2859d7b26febf8e4c87b2efbcb73b7aaafd81108fbe18022edd3515f541287a9`）与真实私钥（`0x128b2fa8bd433c6c068c8d803dff79792a519a55171b1b650c23661d15897263`）不匹配。
  
- **失败原因可能是**：  
  1. 联立方程时未正确代入消息哈希 $e_1/e_2$，导致 $k$ 解算错误；  
  2. 模运算中分母为 0（ $s_2 - s_1 \equiv 0 \mod n$ ），代码未处理此边界条件，推导逻辑断裂。


#### 攻击 3：多用户共享相同 k 值攻击
- **Alice 私钥攻击**：成功  
  推导私钥与真实私钥一致（`0x128b2fa8bd433c6c068c8d803dff79792a519a55171b1b650c23661d15897263`），因 Alice 私钥固定且复用了攻击 1 的公式，无额外变量干扰。

- **Bob 私钥攻击**：失败  
  推导私钥（`0x128b2fa8bd433c6c068c8d803dff79792a519a55171b1b650c23661d15897263`）与真实私钥（`0x5544fff3cfa7ae7c87b6318f9deace259882dd9fbd548ac948b659a1550ec583`）不匹配。
  
- **失败原因**：  
  Bob 私钥为动态生成，代码错误复用 Alice 的私钥推导公式（未针对多用户独立参数实现联立推导），导致逻辑失效。

| 攻击类型                  | 结果 | 核心原因                                                 |
| ------------------------- | ---- | -------------------------------------------------------- |
| k 值泄露攻击              | 成功 | 公式可逆性完整复现，参数无干扰                           |
| 相同 k 值重复使用攻击     | 失败 | 联立方程逻辑不完整（未正确代入消息哈希）或模运算边界未处理 |
| 多用户共享 k 值攻击（Alice） | 成功 | 复用固定私钥的 k 值泄露攻击逻辑，参数单一无干扰           |
| 多用户共享 k 值攻击（Bob）   | 失败 | 动态私钥未适配多用户联立推导，公式复用导致逻辑断裂         |


## 3.中本聪签名伪造
### 3.1 签名伪造原理
&emsp;&emsp;SM2 作为我国商用密码体系的重要公钥密码算法，在数字签名场景保障身份与消息的真实性。然而，若对算法原理与实现边界理解不足，存在签名伪造的潜在风险。本实验聚焦 **“中本聪式” SM2 签名伪造 **，剖析攻击原理与实现路径，揭示算法安全防御的关键要点。
伪造核心是构造满足签名验证条件的 $\((r, s)\)$ ，无需知晓私钥 $\(d\)$ 。通过以下步骤实现：  


#### 1. 哈希与身份绑定  
&emsp;&emsp;计算目标用户的 \( Z_A \)（用户标识与公钥的哈希），生成消息哈希：  
$e = \text{SM3}(Z_A \parallel m)$  


#### 2. 伪造随机参数  
&emsp;&emsp;选取任意 $\( u, v \in [1, n-1] \)$ ，构造伪造点：  $R' = [u]G + [v]P$  
（其中 $\( P \)$ 为目标公钥，$\( G \)$ 为椭圆曲线基点 ）  


#### 3. 签名参数构造  
1. 令 $\( r = (e + x_1') \mod n \)$ $（\( x_1' \)$ 为 $\( R' \)$ 的 $\( x \)$ 坐标 ）。  
2. 令 $\( s = \left( \frac{r}{v} - u \right) \mod n \)$ （通过模逆运算 $\( v^{-1} \mod n \)$ 实现除法，即等价于 $\( s = (r \cdot v^{-1} - u) \mod n \)$ ）。  


#### 4. 验证兼容性  
&emsp;&emsp;伪造的 $\((r, s)\)$ 需满足验证公式：  
$r \equiv e + x_2 \mod n$  

其中 $\( x_2 \)$ 为 $\([s]G + [t]P\)$ 的 $\( x \)4 坐标，且 $\( t = (r + s) \mod n \)$ ，从而通过公钥验证。  

### 3.2 签名伪造实现思路

#### （一）核心步骤拆解

1. **用户身份与公钥绑定**：  
   通过 `get_za` 函数，结合**目标用户 ID**（如 `SATOSHI@BITCOIN.COM` ）和公钥 $\( P \)$ ，生成 $\( Z_A \)$ ，确保哈希预处理与真实签名逻辑一致：  
 ```math
    Z_A = \text{get\_za}(\text{user\_id}, P)
 ```


3. **伪造点构造**：  
   利用椭圆曲线**点乘**（`elliptic_multiply`）和**点加**（`elliptic_add`），生成伪造点：  
    ```math
    R' = [u]G + [v]P 
     ```
   模拟真实签名中的 $\([k]G\)$ 随机点（ $\( G \)$ 为椭圆曲线基点， $\( u, v \in [1, n-1] \)$ 为随机参数 ）。  


4. **签名参数反推**：  
   - 基于伪造点 $\( R' \)$ 的 $\( x \)$ 坐标 $\( x_1' \)$ ，结合消息哈希 $\( e \)$ 构造 $\( r \)$ ：  
      ```math
      r = (e + x_1') \mod n
      ```

   - 通过**模逆运算**反推 $\( s \)$ ，确保满足签名形式（无需知晓私钥 $\( d \)$ ）：  
     ```math
     s \equiv \left( k - r \cdot d \right) \cdot (1 + d)^{-1} \mod n 
      ```
     （实际实现中通过 $\( u, v \)$ 间接构造，等价于 $\( s = \left( \frac{r}{v} - u \right) \mod n \)$ ，依赖 $\( v^{-1} \mod n \)$ 完成除法 ）  


#### （二）关键逻辑适配

1. **随机数与边界处理**：  
&emsp;&emsp;选取 $\( u, v \)$ 时需避开 \( 0 \) 或导致 $\( r, s \)$ 为 $\( 0 \)$ 的值，通过**重试机制**保证参数有效性：

2. **模运算合规性**  
&emsp;&emsp;所有参数需取模 \( n \)（椭圆曲线阶），确保 $\( r, s \in [1, n - 1] \)$ 。通过 `mod_inv` 处理除法（如 $\( v^{-1} \mod n \) ）$ ，避免负数或越界：  
```math
v^{-1} \equiv \text{mod\_inv}(v, n) \pmod{n}  
```

### 3.3 伪造结果
&emsp;&emsp;伪造结果如下：
![实际输出结果](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project5/results/fakesignature.png)
&emsp;&emsp;可以发现伪造签名攻击成功实现！


## 4.实验总结
&emsp;&emsp;本次实验聚焦 SM2 软件实现优化，选择 Python 开展基础实现与算法改进尝试，针对文档提及的签名算法误用，完成 PoC 验证、推导及代码编写，还成功实现中本聪数字签名伪造。过程中明晰 SM2 算法逻辑，验证其签名机制在特定场景的安全风险，通过实践探索优化路径，为 SM2 算法的理解与应用提供实践支撑，后续可深入研究抗伪造增强等方向，完善密码体系应用。



