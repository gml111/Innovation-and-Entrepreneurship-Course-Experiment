# SM4 算法的软件实现与优化

## 1. SM4 分组密码算法实现
### 算法概述  
  SM4 是我国自主设计的分组密码算法，于 2012 年成为国家标准（GB/T 32907-2016）。它是一种迭代型分组密码，分组长度为 128 位，密钥长度为 128 位，采用 32 轮迭代结构。SM4 算法广泛应用于数据加密、隐私保护等领域，具有安全性高、实现效率高的特点。

### 数学原理与算法描述
#### 基本参数
- 分组长度：128 位（16 字节）
- 密钥长度：128 位（16 字节）
- 迭代轮数：32 轮
- 加密与解密使用相同的算法结构，仅轮密钥顺序相反

#### 核心变换
##### 1. S 盒变换（非线性变换）  
  S 盒是 SM4 算法中唯一的非线性部件，用于提供混淆特性。定义为一个 8 位输入到 8 位输出的映射：

$$
S: \{0,1\}^8 \rightarrow \{0,1\}^8
$$

  本实现中使用标准 SM4 S 盒表（见代码实现部分）。

##### 2. 线性变换 L  
  线性变换 L 用于提供扩散特性，定义为：

$$
L(B) = B \oplus (B \ll 2) \oplus (B \ll 10) \oplus (B \ll 18) \oplus (B \ll 24)
$$

  其中 $\ll n$ 表示 32 位循环左移 $n$ 位。

##### 3. 轮函数 F  
  轮函数是 SM4 算法的核心，定义为：

$$
F(X_0, X_1, X_2, X_3, rk) = X_0 \oplus T(X_1 \oplus X_2 \oplus X_3 \oplus rk)
$$

  其中 $T$ 是组合变换：$T(X) = L(\tau(X))$，$\tau(X)$ 是对 X 的每个字节应用 S 盒变换。

##### 4. 密钥扩展  
  轮密钥生成采用与加密类似的结构，使用变换 $T'$：

$$
\begin{aligned}
T'(X) &= L'(\tau(X)) \\
L'(B) &= B \oplus (B \ll 13) \oplus (B \ll 23)
\end{aligned}
$$

  轮密钥 $rk[i]$ 生成公式：

$$
\begin{aligned}
K[i+4] &= K[i] \oplus T'(K[i+1] \oplus K[i+2] \oplus K[i+3] \oplus CK[i]) \\
rk[i] &= K[i+4]
\end{aligned}
$$

  其中 $K[0..3]$ 由初始密钥与系统参数 FK 异或得到，$CK[i]$ 是固定参数。

### 加密流程  
1. 将 128 位明文分为 4 个 32 位字 $X_0, X_1, X_2, X_3$  
2. 进行 32 轮迭代：$X[i+4] = F(X[i], X[i+1], X[i+2], X[i+3], rk[i])$  
3. 最终输出为 $(X_{35}, X_{34}, X_{33}, X_{32})$（逆序排列）  

  具体代码实现见 src 文件，验证 SM4 的执行结果如下：  
![SM4 算法执行结果验证](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project1/results/SM4.png)
##
## 2. SM4 T-table 优化
### 1. 优化背景与原理  
  SM4 算法作为一种迭代型分组密码，其核心运算包括非线性变换（S 盒）和线性变换（L 函数）。在未优化的实现中，每一轮迭代都需要重复计算这些变换，导致大量冗余操作。**T-table 优化**通过预计算将非线性变换与线性变换的组合结果存储在表中，从而减少实际加密过程中的计算量，显著提升执行效率。

#### 优化核心思想
- 将 SM4 中的组合变换 $T(X) = L(\tau(X))$ 和 $T'(X) = L'(\tau(X))$ 预计算为查找表（T-table）
- 加密时直接通过查表替代实时计算，避免重复的 S 盒查找和移位异或操作
- 利用 CPU 缓存特性，将表按缓存行对齐（`alignas(64)`），提升访问速度

### 2. 数学推导与变换定义
#### 2.1 基础变换定义  
1. **非线性变换 τ（S 盒 substitution）**：

$$
\tau(X) = (SBOX[X_0], SBOX[X_1], SBOX[X_2], SBOX[X_3])
$$

  其中 $X = (X_0, X_1, X_2, X_3)$ 为 32 位输入的四个字节分量。

2. **线性变换 L**：

$$
L(B) = B \oplus (B \ll 2) \oplus (B \ll 10) \oplus (B \ll 18) \oplus (B \ll 24)
$$

3. **线性变换 L'（密钥扩展用）**：

$$
L'(B) = B \oplus (B \ll 13) \oplus (B \ll 23)
$$

### 2.2 T-table 预计算推导
#### 组合变换定义  
  定义加密轮函数用组合变换 $T(X)$ 和密钥扩展用组合变换 $T'(X)$：

$$
\begin{aligned}
T(X) &= L\bigl(\tau(X)\bigr) \quad \text{// 加密轮函数用} \\
T'(X) &= L'\bigl(\tau(X)\bigr) \quad \text{// 密钥扩展用}
\end{aligned}
$$

#### 预计算规则（加密轮函数 $T(X)$）  
  对于任意字节值 $b \in [0, 255]$，按字节位置（**最高位 → 最低位**）预计算，结果存储到对应表中：

| 字节位置 | 预计算逻辑（数学表达式）                  | 存储变量 |
|----------|------------------------------------------|----------|
| 最高位   | $T_0[b] = L\bigl(\text{SBOX}[b] \ll 24\bigr)$ | $T_0$    |
| 次高位   | $T_1[b] = L\bigl(\text{SBOX}[b] \ll 16\bigr)$ | $T_1$    |
| 次低位   | $T_2[b] = L\bigl(\text{SBOX}[b] \ll 8\bigr)$  | $T_2$    |
| 最低位   | $T_3[b] = L\bigl(\text{SBOX}[b]\bigr)$        | $T_3$    |

#### 组合变换简化  
  通过预计算，加密时的组合变换可直接通过**查表异或**实现：

$$
T(X) = T_0[X_0] \oplus T_1[X_1] \oplus T_2[X_2] \oplus T_3[X_3]
$$

  其中 $(X_0, X_1, X_2, X_3)$ 是 32 位输入 $X$ 拆分后的四个字节分量。

#### 密钥扩展用预计算  
  同理，密钥扩展用的 $T'(X)$ 按相同方式预计算（仅线性变换替换为 $L'$ ），存储为 $Tp_0 \sim Tp_3$ 表，逻辑与 $T(X)$ 一致。

### 3. 优化效果分析  
  T-table 优化通过以下方式提升性能：
- 减少计算量：将每次迭代中的 4 次 S 盒查找和多次移位异或操作替换为 4 次查表操作
- 提升缓存利用率：表数据按缓存行对齐，减少缓存未命中（cache miss）
- 支持循环展开：简化的查表操作更适合编译器进行循环展开优化，充分利用 CPU 流水线

### 4. 实际测试结果  
  实际测试中，T-table 优化通常可使 SM4 加密速度提升 1.5~2 倍（具体取决于硬件平台），是软件优化中性价比极高的优化手段。具体结果如下：  
![SM4算法执行结果验证](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project1/results/SM4_T-table.png)

##
## 3. SM4 AES-NI 优化
### 1. 优化背景与原理  
  **AES-NI 优化**利用 CPU 内置的 AES 硬件加速指令集，直接在硬件层面执行类似 S 盒的非线性变换，大幅降低计算延迟，提升整体加密性能。

#### 优化核心思想
- 用硬件加速的 AES 指令（`_mm_aesenclast_si128`）替代软件 S 盒查表，加速非线性变换
- 保持 SM4 原有线性变换 L 的数学逻辑，仅优化最耗时的 S 盒部分
- 通过 CPU 指令集检测动态适配，在不支持 AES-NI 的平台自动降级为基础实现

### 2. 数学推导与变换定义

### 硬件加速的非线性变换  
  利用 AES-NI 指令集中的硬件 S 盒替换软件查表，定义硬件加速的非线性变换：

$$
\tau_{\text{AES-NI}}(X) = \text{AES-SBOX}(X_0, X_1, X_2, X_3)
$$

  其中 $\text{AES-SBOX}$ 表示通过 `_mm_aesenclast_si128` 指令实现的硬件字节替换。
#### 优化后的组合变换  
  保持线性变换 L 不变，仅替换非线性部分，优化后的 $T$ 函数：

$$
T_{\text{AES-NI}}(X) = L\bigl(\tau_{\text{AES-NI}}(X)\bigr)
$$

  该变换与原始 $T(X)$ 数学等价，但计算效率显著提升。

### 3. 优化效果分析  
 AES-NI 优化通过以下方式提升性能：硬件并行计算，将 S 盒变换从软件查表（多次内存访问）转为硬件指令单次完成，降低延迟；减少缓存依赖，避免软件查表对 CPU 缓存的频繁占用，提升整体内存效率；保持算法一致性，仅替换计算方式，不改变 SM4 算法的数学逻辑和加密结果。在支持 AES-NI 的 CPU 上，该优化通常可使 SM4 加密速度提升 1.5~2 倍。

##
## 4. SM4 GFNI 优化
### 1. 优化背景与原理  
  **GFNI（Galois Field New Instructions）优化**利用 CPU 内置的有限域运算指令集，直接在硬件层面执行类似 S 盒的非线性变换，进一步提升 SM4 算法的性能。GFNI 指令集提供了高效的有限域运算能力，特别是 `_mm_gf2p8affine_epi64_epi8` 指令，可以直接完成仿射变换。

#### 优化核心思想
- 使用 GFNI 指令集中的 `_mm_gf2p8affine_epi64_epi8` 指令替代软件 S 盒查表，加速非线性变换。
- 保持 SM4 原有线性变换 L 的数学逻辑，仅优化最耗时的 S 盒部分。
- 通过 CPU 指令集检测动态适配，在不支持 GFNI 的平台自动降级为基础实现。

### 2. 数学推导与变换定义

#### 硬件加速的非线性变换  
  利用 GFNI 指令集中的硬件仿射变换指令替换软件 S 盒查表，定义硬件加速的非线性变换：

$$
\tau_{\text{GFNI}}(X) = \text{GF2P8AFFINE}(X_0, X_1, X_2, X_3, A, b)
$$

 其中 $\text{GF2P8AFFINE}$ 表示通过 `_mm_gf2p8affine_epi64_epi8` 指令实现的硬件仿射变换，$A$ 为仿射矩阵，$b$ 为常向量，$X = (X_0, X_1, X_2, X_3)$ 为 32 位输入的四个字节分量。

#### 优化后的组合变换  
  保持线性变换 L 不变，仅替换非线性部分，优化后的 $T$ 函数：

$$
T_{\text{GFNI}}(X) = L\bigl(\tau_{\text{GFNI}}(X)\bigr)
$$

  该变换与原始 $T(X)$ 数学等价，但计算效率显著提升。

### 3. 优化效果分析  
  GFNI 优化通过以下方式提升性能：硬件并行计算，将 S 盒变换从软件查表（多次内存访问）转为硬件指令单次完成，降低延迟；减少缓存依赖，避免软件查表对 CPU 缓存的频繁占用，提升整体内存效率；保持算法一致性，仅替换计算方式，不改变 SM4 算法的数学逻辑和加密结果。在支持 GFNI 的 CPU 上，该优化通常可使 SM4 加密速度提升 2~3 倍。

### 4. 实际测试结果  
  实际测试中，GFNI 优化后的 SM4 算法在支持 GFNI 指令集的 CPU 上表现出了性能提升。以下是优化后的性能对比结果：  
![SM4 GFNI 优化性能对比](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project1/results/SM4_GFNI.png)

##
## 5. SM4 算法的 AVX512 优化实现

### 1. 优化背景与原理  
#### AVX512 指令集  
  AVX512 是 Intel 提供的高级矢量扩展指令集，支持 512 位宽的矢量操作，能够同时处理多个数据，从而提高计算效率。通过 AVX512，可以将多个 SM4 加密块并行处理，减少 CPU 的指令执行次数。

#### 优化核心思想  
- **并行处理**：利用 AVX512 指令集，将多个 SM4 加密块（16 个块，共 256 字节）并行处理。
- **减少内存访问**：通过减少对 S 盒的逐字节访问，降低内存延迟。
- **动态适配**：在不支持 AVX512 的平台上，自动回退到标量实现。

### 2. 数学推导与变换定义  

##### 2.1 非线性变换 τ（S 盒）  
  定义硬件加速的非线性变换：

$$
\tau_{\text{AVX512}}(X) = \text{VPSHUFB}(X_0, X_1, X_2, X_3, \text{SBOX})
$$

  其中 $\text{VPSHUFB}$ 表示通过 AVX512 指令集中的向量置换指令实现的并行 S 盒变换，$X = (X_0, X_1, X_2, X_3)$ 为 32 位输入的四个字节分量，$\text{SBOX}$ 为预加载的向量形式 S 盒表。

##### 2.2 线性变换 L  
  保持线性变换 L 的数学逻辑不变，通过 AVX512 向量指令并行执行：

$$
L_{\text{AVX512}}(B) = B \oplus (B \ll 2) \oplus (B \ll 10) \oplus (B \ll 18) \oplus (B \ll 24)
$$

  其中 $\ll n$ 表示 32 位循环左移 $n$ 位，通过 $\text{VPSLLVD}$ 和 $\text{VPXOR}$ 指令实现多组并行移位与异或。

##### 2.3 优化后的组合变换  
  保持变换逻辑不变，通过向量指令并行处理多组输入，优化后的 $T$ 函数：

$$
T_{\text{AVX512}}(X) = L_{\text{AVX512}}\bigl(\tau_{\text{AVX512}}(X)\bigr)
$$

  该变换与原始 $T(X)$ 数学等价，但通过并行处理提升计算效率。

### 3. 代码实现思路
  主要利用了AVX512指令集的并行处理能力，通过将多个SM4加密块（16个块，共256字节）并行处理，显著提高了加密效率。在实现中，首先检查是否支持AVX512指令集，如果不支持则回退到标量实现。对于支持AVX512的情况，通过加载和转换数据到512位宽的寄存器中，利用AVX512的指令进行并行计算，减少了逐字节处理的开销。在加密过程中，对每个加密块应用SM4的轮函数，包括非线性变换（S盒）和线性变换（L函数），并通过循环左移等操作完成线性扩散。最终，将处理后的数据存储回内存，并转换回大端序格式以符合输出要求。此外，还实现了验证功能，确保优化后的实现与标量实现结果一致，并通过基准测试对比了标量和AVX512优化实现的性能差异。

 ### 4. 实际测试结果  
  实际测试中，AVX512 优化后的 SM4 算法在支持 AVX512 指令集的 CPU 上表现出了性能提升。以下是优化后的性能对比结果：  
![SM4 GFNI 优化性能对比](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project1/results/SM4_VPROLD.png)


##
## 6. SM4-GCM 算法的优化实现

### 1. 优化背景与原理  
  SM4-GCM 是一种结合了 SM4 分组密码算法和 Galois/Counter Mode（GCM）的加密模式，广泛应用于需要高效加密和认证的场景。传统的 SM4-GCM 实现中，加密和认证部分通常分别处理，效率较低。通过优化，可以显著提升整体性能。

#### 1.1 优化核心思想  
- **并行处理**：通过优化 S 盒和线性变换，减少逐字节处理的开销。
- **硬件加速**：利用现代 CPU 的指令集（如 AVX2、AVX512）进行硬件加速。
- **减少内存访问**：通过减少对 S 盒的逐字节访问，降低内存延迟。
- **优化 GHASH 计算**：通过表查找优化 GHASH 的乘法运算。

### 2. 数学推导与变换定义  

##### 2.1 SM4 加密轮函数优化  
  SM4 的加密轮函数包括非线性变换（S 盒）和线性变换（L 函数），优化后的组合变换：

$$
T_{\text{opt}}(X) = L_{\text{opt}}\bigl(\tau_{\text{opt}}(X)\bigr)
$$

  其中：  
  - 硬件加速的非线性变换：  
$$\tau_{\text{opt}}(X) = \text{VPSHUFB}(X_0, X_1, X_2, X_3, \text{SBOX})$$  
  （$\text{VPSHUFB}$ 表示向量并行 S 盒查找，$X = (X_0, X_1, X_2, X_3)$ 为 32 位输入的字节分量）  

  - 并行化线性变换：  
$$L_{\text{opt}}(B) = B \oplus (B \ll 2) \oplus (B \ll 10) \oplus (B \ll 18) \oplus (B \ll 24)$$  
  （通过向量移位指令 $\text{VPSLLVD}$ 实现多组并行左移）

##### 2.2 GHASH 函数优化  
  GHASH 函数用于 GCM 模式中的认证部分，优化后的定义：

$$
\text{GHASH}_{\text{opt}}(H, X) = \text{TABLE}[X] \oplus \text{REDUCE}(X \cdot H)
$$

  其中：  
  - $H$ 是加密的哈希密钥，$X$ 是输入数据（按 128 位分组）  
  - $\text{TABLE}[X]$ 是预计算的乘法表，替代实时有限域乘法  
  - $\text{REDUCE}$ 是通过向量指令实现的并行模约简操作  

  优化后通过硬件指令集实现多组数据的并行哈希计算，降低认证过程的时间开销。

  ### 3. 具体代码实现
  主要思路是通过减少逐字节处理的开销和利用硬件加速来提升性能。具体来说，本代码优化了S盒的查找操作，通过预计算和并行处理减少了对S盒的逐字节访问，降低了内存延迟。同时，本代码还优化了线性变换，减少了循环左移等操作的执行次数。对于GHASH函数，本代码通过表查找的方式优化了乘法运算，进一步提高了认证部分的效率。整体上，这些优化措施显著减少了CPU的指令执行次数，提升了加密和认证的效率

   ### 4. 实际测试结果  
  实际测试中，优化后的 SM4 算法表现出的性能提升如下：  
![SM4 GFNI 优化性能对比](https://raw.githubusercontent.com/gml111/Innovation-and-Entrepreneurship-Course-Experiment/main/Project1/results/SM4_GCM.png)



# 实验总结
## SM4及SM4-GCM优化方式对比分析

### 优化方式效率对比表

| 优化方式       | 吞吐量提升倍数 | 硬件依赖要求               | 实现复杂度 | 适用场景                                     | 主要优势                                         | 主要劣势                                         |
|----------------|----------------|----------------------------|------------|----------------------------------------------|--------------------------------------------------|--------------------------------------------------|
| 基础实现       | 1x（基准）     | 无                         | 低         | 对性能要求低、跨平台兼容性优先的场景         | 实现简单，兼容性好                               | 性能最差，无优化                                 |
| T-table优化    | 1.5~2x         | 无（依赖CPU缓存）          | 中         | 通用场景，尤其适合缓存友好型应用             | 无硬件依赖，性价比高，提升稳定                   | 占用额外内存（约8KB），缓存压力略增               |
| AES-NI优化     | 2~3x           | 支持AES-NI的CPU（2010年后） | 中         | 服务器、PC等主流平台的加密场景               | 硬件加速显著，兼容性较好（大部分现代CPU支持）     | 依赖特定指令集，老旧硬件无法使用                 |
| GFNI优化       | 2.5~4x         | 支持GFNI的CPU（2020年后）  | 高         | 最新硬件平台（如Intel Ice Lake及以后）       | 有限域运算硬件加速，非线性变换效率最优           | 硬件兼容性差（仅最新CPU支持），实现复杂           |
| AVX512优化     | 4~8x           | 支持AVX512的CPU            | 高         | 高性能计算、批量加密场景（如数据中心）       | 512位向量并行处理，多块加密效率极高               | 硬件成本高，功耗较大，小数据量加密优势不明显     |
| SM4-GCM优化    | 1.8~3.5x       | 视底层优化（如结合AES-NI/GFNI） | 高 | 需要同时加密和认证的场景（如通信协议、存储加密） | 兼顾加密与认证，并行处理GHASH提升整体效率         | 实现复杂，认证部分（GHASH）优化难度高             |

### 总结
  选择优化方式时，需综合考虑**目标硬件平台**、**性能需求**、**实现复杂度及兼容性要求**，优先选择与硬件匹配度最高的方案以发挥最大效率。
通用场景首选 T-table 优化：无硬件依赖，实现简单且性能提升稳定，适合大多数跨平台应用。
主流硬件优先 AES-NI：现代 CPU 普遍支持，性能提升显著，平衡了兼容性与效率。
最新硬件推荐 GFNI：在支持 GFNI 的 CPU 上，非线性变换效率最优，适合对加密性能要求极高的场景。
批量处理选 AVX512：多块并行处理优势明显，适合数据中心、大数据加密等场景，但硬件成本较高。
需认证场景用 SM4-GCM 优化：结合加密与认证，通过优化 GHASH 计算提升整体效率，适合通信、存储等安全协议。

